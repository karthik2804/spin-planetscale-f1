import SqlString from 'sqlstring';
import { utf8Encode } from './text.js';
export class Client {
    constructor(config) {
        this.config = config;
    }
    async execute(query, args) {
        return this.connection().execute(query, args);
    }
    connection() {
        return new Connection(this.config);
    }
}
export class Connection {
    constructor(config) {
        if (typeof fetch !== 'undefined') {
            config = { fetch, ...config };
        }
        this.config = config;
        this.session = null;
    }
    async refresh() {
        try {
            await this.createSession();
            return true;
        }
        catch {
            return false;
        }
    }
    async createSession() {
        const url = new URL('/psdb.v1alpha1.Database/CreateSession', `https://${this.config.host}`);
        const { session } = await this.postJSON(url);
        this.session = session;
        return session;
    }
    async postJSON(url, body = {}) {
        const auth = btoa(`${this.config.username}:${this.config.password}`);
        const { fetch } = this.config;
        const response = await fetch(url.toString(), {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Basic ${auth}`
            }
        });
        if (response.ok) {
            return await response.json();
        }
        else {
            throw new Error(`${response.status} ${response.statusText}`);
        }
    }
    async execute(query, args) {
        const startTime = Date.now();
        const url = new URL('/psdb.v1alpha1.Database/Execute', `https://${this.config.host}`);
        query = SqlString.format(query, args, false, 'UTC');
        const saved = await this.postJSON(url, {
            query: query,
            session: this.session
        });
        const time = Date.now() - startTime;
        const { result, session, error } = saved;
        const rowsAffected = result?.rowsAffected ? parseInt(result.rowsAffected, 10) : null;
        const insertId = result?.insertId ?? null;
        this.session = session;
        const rows = result ? parse(result) : [];
        const headers = result ? result.fields?.map((f) => f.name) ?? [] : [];
        return {
            headers,
            rows,
            rowsAffected,
            insertId,
            error: error ?? null,
            size: rows.length,
            statement: query,
            time
        };
    }
}
export function connect(config) {
    return new Connection(config);
}
function parseRow(fields, rawRow) {
    const row = decodeRow(rawRow);
    return fields.reduce((acc, field, ix) => {
        acc[field.name] = parseColumn(field.type, row[ix]);
        return acc;
    }, {});
}
function parse(result) {
    const fields = result.fields;
    const rows = result.rows ?? [];
    return rows.map((row) => parseRow(fields, row));
}
function decodeRow(row) {
    const values = atob(row.values);
    let offset = 0;
    return row.lengths.map((size) => {
        const width = parseInt(size, 10);
        if (width < 0)
            return null;
        const splice = values.substring(offset, offset + width);
        offset += width;
        return splice;
    });
}
function parseColumn(type, value) {
    if (value === '' || value == null) {
        return value;
    }
    switch (type) {
        case 'INT8':
        case 'INT16':
        case 'INT24':
        case 'INT32':
        case 'INT64':
        case 'UINT8':
        case 'UINT16':
        case 'UINT24':
        case 'UINT32':
        case 'UINT64':
            return parseInt(value, 10);
        case 'FLOAT32':
        case 'FLOAT64':
        case 'DECIMAL':
            return parseFloat(value);
        default:
            return utf8Encode(value);
    }
}
